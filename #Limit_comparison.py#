import math as m
import numpy as np
import csv
import matplotlib.pyplot as plt
import astropy.units as u
import pandas as pd
import random as rand
import astropy.coordinates as coord
import astropy.units as u
from astropy.io import ascii
from astropy.coordinates import SkyCoord, EarthLocation, AltAz, concatenate
from astropy import coordinates as coord
from astropy.coordinates.tests.utils import randomly_sample_sphere
from astropy.time import Time
from astropy import units as u
from skyfield.api import load
from skyfield.api import Topos
import math
from collections import OrderedDict

import numpy as np
import pandas as pd

from km3astro.coord import local_event, local_frame, neutrino_to_source_direction
from matplotlib import pyplot as plt
import numpy as np
import healpy as hp

from km3astro.coord import (
    local_event,
    neutrino_to_source_direction,
    sun_local,
    get_location,
    convergence_angle,
    utm_zone,
    longitude_of_central_meridian,
)



total=[]
lg=[]
bg=[]
x_bins = np.linspace(0,360,181)
y_bins = np.linspace(-90,90,91)
theta_deg=[]
phi_deg=[]

ra_deg=rand.uniform(0,360)
decl_deg=rand.uniform(-61,8)
c = SkyCoord(ra_deg, decl_deg, frame="icrs", unit="deg")

#--------------------------------------------------------------
# Setting of healpy resolution map and n. of pixels
#--------------------------------------------------------------
NSIDE = 32 # this sets the side resolution of each one of the 12 basic-macro pixels
print("Approximate resolution at NSIDE {} is {:.2} deg".format(NSIDE, hp.nside2resol(NSIDE, arcmin=True) / 60))
NPIX = hp.nside2npix(NSIDE)
print("number of pixels in the map",NPIX)

def cat2hpx(lon, lat, nside, radec=True):
    """
    Convert a catalogue to a HEALPix map of number counts per resolution
    element.

    Parameters
    ----------
    lon, lat : (ndarray, ndarray)
        Coordinates of the sources in degree. If radec=True, assume input is in the icrs
        coordinate system. Otherwise assume input is glon, glat

    nside : int
        HEALPix nside of the target map

    radec : bool
        Switch between R.A./Dec and glon/glat as input coordinate system.

    Return
    ------
    hpx_map : ndarray
        HEALPix map of the catalogue number counts in Galactic coordinates

    """

    npix = hp.nside2npix(nside)

    if radec:
        eq = SkyCoord(lon, lat, 'icrs', unit='deg')
        l, b = eq.galactic.l.value, eq.galactic.b.value
    else:
        l, b = lon, lat
    # conver to theta, phi
    #theta conversion to port the b [-90,90] to the colatitude range [0,180]
    theta = np.radians(90. - b)
    phi = np.radians(l)

    # convert to HEALPix indices
    indices = hp.ang2pix(nside, theta, phi)

    idx, counts = np.unique(indices, return_counts=True)

    # fill the fullsky map
    hpx_map = np.zeros(npix, dtype=int)
    hpx_map[idx] = counts

    return hpx_map
#--------------------------------------------------------------
#setting to zero all the map m
#--------------------------------------------------------------
m = np.zeros(hp.nside2npix(NSIDE))
commonl=[]
commonb=[]

for a in range(len(total[tt].l.deg)):
    commonl.append(total[tt].l[a].deg)
    commonb.append(total[tt].b[a].deg)
    common = SkyCoord(commonl, commonb,frame='galactic', unit='deg')
hpx_map = cat2hpx(common.l.deg, common.b.deg, nside=32, radec=False)
#hpx_map = cat2hpx(eqsky.ra.deg,eqsky.dec.deg, nside=32, radec=False)
#hp.mollview(hpx_map, title="Mollview image RING")
hp.mollview(np.log10(hpx_map+1), title="Antares sky coverage")
hp.graticule()
plt.show()



